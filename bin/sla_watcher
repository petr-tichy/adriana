#!/usr/bin/env ruby
# 1.9 adds realpath to resolve symlinks; 1.8 doesn't
# have this method, so we add it so we get resolved symlinks
# and compatibility
require 'rubygems'
require 'bundler/setup'
require 'active_record'
require 'gli'
require 'pp'
require 'passwordmanager'
require_relative "../lib/sla_watcher.rb"
require 'pony'
require 'activerecord-import'
require 'pagerduty/full'
require 'yaml'


include GLI::App

program_desc 'Program for SLA checking'


desc 'Synchronize with Splunk'
command :splunk_synchronization do |c|
  c.action do |global_options,options,args|

    $type = "splunk_synchronization"

    SLAWatcher.connect_to_db(@postgres_hostname,@postgres_port,@postgres_username,@postgres_password,@postgres_database)
    PasswordManagerApi::PasswordManager.connect(@passman_adress,@passman_port,@passman_key)
    splunk = SLAWatcher.splunk(@splunk_username,@splunk_password,@splunk_hostname)


    # Load the last time when the synchronization was executed
    last_run = SLAWatcher.load_last_run
    now      = DateTime.now
    # Load all CC project which need to be monitored
    projects = SLAWatcher.get_projects


    # Returns all events for given set of project in given time frame
    events = splunk.load_runs(last_run - 24.hours,now,projects)

    starts = events.find_all{|e| e[:status] == 'STARTED'}
    errors_finished = events.find_all{|e| e[:status] != 'STARTED'}


    starts = SLAWatcher.check_request_id(starts,'STARTED')
    errors_finished = SLAWatcher.check_request_id(errors_finished,'FINISHED')



    # We need to use transaction, because of UPDATE on the end of the query
    ActiveRecord::Base.transaction do
      # Save the events to the database
      starts.each do |event|
        SLAWatcher.log_execution_splunk(event[:project_pid],event[:clover_graph],event[:mode],event[:status],"From Splunk synchronizer",event[:time],event[:request_id])
      end

      errors_finished.each do |event|
        SLAWatcher.log_execution_splunk(event[:project_pid],event[:clover_graph],event[:mode],event[:status],"From Splunk synchronizer",event[:time],event[:request_id])
      end

      #Save the last run date
      SLAWatcher.save_last_run(now)
    end
  end
end

desc 'Synchronize with Splunk'
command :api_synchronization do |c|
  c.action do |global_options,options,args|

    $type = "api_synchronization"

    SLAWatcher.connect_to_db(@postgres_hostname,@postgres_port,@postgres_username,@postgres_password,@postgres_database)
    PasswordManagerApi::PasswordManager.connect(@passman_adress,@passman_port,@passman_key)
    SLAWatcher.snifer

  end
end



desc 'Synchronize with Splunk'
command :migration do |c|
  c.action do |global_options,options,args|
    $type = "migration"

    SLAWatcher.connect_to_db(@postgres_hostname,@postgres_port,@postgres_username,@postgres_password,@postgres_database)
    SLAWatcher.start_migration
  end
end


desc 'Test'
command :test do |c|
  c.action do |global_options,options,args|

    $type = "test"

    SLAWatcher.connect_to_db(@postgres_hostname,@postgres_port,@postgres_username,@postgres_password,@postgres_database)
    SLAWatcher.pd_entity = PagerDuty::Full.new(apikey = @pd_api_key, subdomain = @pd_subdomain)
    SLAWatcher.pd_service = @pd_service
    SLAWatcher.test

  end
end


desc 'Development'
command :development do |c|
  c.action do |global_options,options,args|

    SLAWatcher.connect_to_db(@postgres_hostname,@postgres_port,@postgres_username,@postgres_password,@postgres_database)
    PasswordManagerApi::PasswordManager.connect(@passman_adress,@passman_port,@passman_key)
    SLAWatcher.pd_entity = PagerDuty::Full.new(apikey = @pd_api_key, subdomain = @pd_subdomain)
    SLAWatcher.pd_service = @pd_service
    SLAWatcher.development

  end
end









desc 'Tests'
command :not_started do |c|
#  c.desc 'Execute only for one entity.'
#  c.default_value false
#  c.flag [:o, :only]

  c.action do |global_options,options,args|
    sla_watcher = SLAWatcher.client()
    #sla_watcher.timeline
    #sla_watcher.projects
    sla_watcher.projects.projects.each_pair do |pid,project|
      pp project

    end

  end
end


desc 'Tests'
command :testcase do |c|
#  c.desc 'Execute only for one entity.'
#  c.default_value false
#  c.flag [:o, :only]

  c.action do |global_options,options,args|
    $type = "testcase"

    SLAWatcher.connect_to_db(@postgres_hostname,@postgres_port,@postgres_username,@postgres_password,@postgres_database)
    SLAWatcher.run_test_case
  end
end



desc 'Sync data from spredsheet to postgress db'
command :sync_google do |c|
#  c.desc 'Execute only for one entity.'
#  c.default_value false
#  c.flag [:o, :only]
  c.action do |global_options,options,args|
    SLAWatcher.connect_to_db(@postgres_hostname,@postgres_port,@postgres_username,@postgres_password,@postgres_database)
    $type = "sync_google"
    wrongly_logged = SLAWatcher.get_wrongly_logged_executions
    wrongly_logged.each do |execution|
      now = Time.now().utc
      if (now - execution.event_start > 12.hours)
        execution.event_end = now
        execution.status = "ERROR"
        execution.detailed_status = "Automatic fix after 12hours"
        execution.save
        Pony.mail(:to => "adrian.toman+sla@gooddata.com,petr.tichy+sla@gooddata.com",:from => 'sla@gooddata.com', :subject => "The execution was automaticaly closed", :body => "The execution for #{execution.project_name} (#{execution.project_pid}) was automatically closed after 12h. If there are more errors for one project in line, it looks like something is wrong with this project." )
      end
    end
  end
end


desc 'Run remove notification job'
command :remove_notification do |c|
#  c.desc 'Execute only for one entity.'
#  c.default_value false
#  c.flag [:o, :only]
  c.action do |global_options,options,args|
    SLAWatcher.connect_to_db(@postgres_hostname,@postgres_port,@postgres_username,@postgres_password,@postgres_database)
    PasswordManagerApi::PasswordManager.connect(@passman_adress,@passman_port,@passman_key)
    $type = "remove_notification"
    SLAWatcher.run_notification_removal_task
  end
end






pre do |global,command,options,args|
  next true if command.nil?
  @running = false
  @not_delete = false
  @command = command.name
  @@log = Logger.new("log/sla_#{command.name}.log",'daily') if ENV["USERNAME"] != "adrian.toman"
  #@@log = Logger.new("log/sla_watcher.log",'daily')
  @@log = Logger.new(STDOUT) if ENV["USERNAME"] == "adrian.toman"

  File.open( "config/config.json", "r" ) do |f|
    json = JSON.load( f )
    @splunk_username = json["splunk_username"]
    @splunk_password = json["splunk_password"]
    @splunk_hostname = json["splunk_hostname"]
    @postgres_hostname = json["postgres_hostname"]
    @postgres_port = json["postgres_port"]
    @postgres_username = json["postgres_username"]
    @postgres_password = json["postgres_password"]
    @postgres_database = json["postgres_database"]
    @google_username = json["google_username"]
    @google_password = json["google_password"]
    @passman_adress = json["passman_adress"]
    @passman_port = json["passman_port"]
    @passman_key = json["passman_key"]
    @pd_api_key = json["pd_api_key"]
    @pd_subdomain = json["pd_subdomain"]
    @pd_service = json["pd_service"]
  end

  if File.exists?("running_#{command.name}.pid")
    @running = true
    @not_delete = true
    exit_now! "Another process for this command is running"
  end
  FileUtils.touch("running_#{command.name}.pid")
  # Pre logic here
  # Return true to proceed; false to abourt and not call the
  # chosen command
  # Use skips_pre before a command to skip this block
  # on that command only
  true
end

post do |global,command,options,args|
  FileUtils.rm_f("running_#{command.name}.pid") if !@running
  #Pony.mail(:to => "adrian.toman@gooddata.com",:from => 'sla@gooddata.com', :subject => "SLA Synchronization - Some work was done in #{command.name}", :body => "File in attachements", :attachments => {"sla_#{command.name}.log" => File.read("log/sla_#{command.name}.log")})
end

on_error do |exception|
  FileUtils.rm_f("running_#{@command}.pid") if !@not_delete
  #Pony.mail(:to => "adrian.toman@gooddata.com,petr.tichy+sla@gooddata.com",:from => 'sla@gooddata.com', :subject => "SLA Synchronization - Error - #{$type}", :body => "Error: #{exception.backtrace}" )
  pp exception.backtrace
  if exception.is_a?(SystemExit) && exception.status == 0
    false
  else
    pp exception.inspect
    false
  end
end


exit run(ARGV)
