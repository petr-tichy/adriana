#!/usr/bin/env ruby
# 1.9 adds realpath to resolve symlinks; 1.8 doesn't
# have this method, so we add it so we get resolved symlinks
# and compatibility
require 'rubygems'
require 'bundler/setup'
require 'active_record'
require 'gli'
require 'pp'
require "lib/sla_watcher.rb"
require 'pony'


include GLI

program_desc 'Program for SLA checking'


desc 'Synchronize with Splunk'
command :splunk_synchronization do |c|
  c.action do |global_options,options,args|

    SLAWatcher.connect_to_db(@postgres_hostname,@postgres_port,@postgres_username,@postgres_password,@postgres_database)
    splunk = SLAWatcher.splunk(@splunk_username,@splunk_password,@splunk_hostname)


    # Load the last time when the synchronization was executed
    last_run = SLAWatcher.load_last_run
    now      = DateTime.now
    # Load all CC project which need to be monitored
    projects = SLAWatcher.get_projects


    # Returns all events for given set of project in given time frame
    events = splunk.load_runs(last_run,now,projects)

    # We need to use transaction, because of UPDATE on the end of the query
    ActiveRecord::Base.transaction do
      # Save the events to the database
      events.each do |event|
        SLAWatcher.log_execution(event[:project_pid],event[:clover_graph],event[:mode],event[:status],"From Splunk synchronizer",event[:time])
      end

      #Save the last run date
      SLAWatcher.save_last_run(now)
    end
  end
end

desc 'Synchronize with Splunk'
command :migration do |c|
  c.action do |global_options,options,args|

    SLAWatcher.connect_to_db(@postgres_hostname,@postgres_port,@postgres_username,@postgres_password,@postgres_database)
    SLAWatcher.start_migration
  end
end


desc 'Test'
command :test do |c|
  c.action do |global_options,options,args|


    SLAWatcher.connect_to_db(@postgres_hostname,@postgres_port,@postgres_username,@postgres_password,@postgres_database)
    SLAWatcher.test

  end
end







desc 'Tests'
command :not_started do |c|
#  c.desc 'Execute only for one entity.'
#  c.default_value false
#  c.flag [:o, :only]

  c.action do |global_options,options,args|
    sla_watcher = SLAWatcher.client()
    #sla_watcher.timeline
    #sla_watcher.projects
    sla_watcher.projects.projects.each_pair do |pid,project|
      pp project

    end

  end
end




pre do |global,command,options,args|
  next true if command.nil?
  @@log = Logger.new("log/sla_#{command.name}.log",'daily') if ENV["USERNAME"] != "adrian.toman"
  #@@log = Logger.new("log/sla_watcher.log",'daily')
  @@log = Logger.new(STDOUT) if ENV["USERNAME"] == "adrian.toman"

  File.open( "config/config.json", "r" ) do |f|
    json = JSON.load( f )
    @splunk_username = json["splunk_username"]
    @splunk_password = json["splunk_password"]
    @splunk_hostname = json["splunk_hostname"]
    @postgres_hostname = json["postgres_hostname"]
    @postgres_port = json["postgres_port"]
    @postgres_username = json["postgres_username"]
    @postgres_password = json["postgres_password"]
    @postgres_database = json["postgres_database"]
  end



  # Pre logic here
  # Return true to proceed; false to abourt and not call the
  # chosen command
  # Use skips_pre before a command to skip this block
  # on that command only
  true
end

post do |global,command,options,args|
  #Pony.mail(:to => "adrian.toman@gooddata.com",:from => 'sla@gooddata.com', :subject => "SLA Synchronization - Some work was done in #{command.name}", :body => "File in attachements", :attachments => {"sla_#{command.name}.log" => File.read("log/sla_#{command.name}.log")})
end

on_error do |exception|
  Pony.mail(:to => "adrian.toman@gooddata.com",:from => 'sla@gooddata.com', :subject => "SLA Synchronization - Error", :body => "Error: #{exception.backtrace}" )
  pp exception.backtrace
  if exception.is_a?(SystemExit) && exception.status == 0
    false
  else
    pp exception.inspect
    false
  end
end


exit GLI.run(ARGV)
